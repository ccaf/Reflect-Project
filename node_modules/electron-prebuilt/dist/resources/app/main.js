var app = require('app');

var BrowserWindow = require('browser-window'),
  mainWindow = null;

var Datastore = require('nedb'),
  db = global.db = new Datastore({filename: __dirname + '/embedded.db', autoload: true});

// TODO: make user configurable.
var ports = {
  'http': 1867,
  'wsClient': 904
};

require('./httpServer').init(ports.http);

// Some helper methods.
// A "poor" assert for simple type checking, etc.
var debug = true;
global.assert = function assert(condition, message) {
  if (debug && !condition)
    throw new Error(message || 'Assert failed.');
};

global.type = function type(unknown) {
  var t = typeof unknown;

  if (unknown === null) return type.null;
  if (t === 'undefined') return type.undefined;
  if (t === 'number') return type.number;
  if (t === 'string') return type.string;
  if (unknown.constructor === Array) return type.array;
  if (t === 'object') return type.object;
  if (Object.prototype.toString.call(unknown) == '[object Function]') return type.function;
};

type.number = 0; type.string = 1; type.array = 2; type.object = 3; type.function = 4; type.undefined = 5; type.null = 6;

// WebSocket servers for client and admin connections.
// We also add a conns property which is an array of current connections.
// When clients associate, we also assign their classroom and id to their conn.
// So e.g. conns[0] = {..., 'classroom': [...], '_id': [...], ...}
// This makes it easy to associate a connection with a device and vice versa.
var wsClient = null;

// A module containing JSON schemas for all data that goes into the database.
// Any data written to the database must validate or the write will not succeed.
var schema = require('./schema').def;
var v = new(require('jsonschema').Validator)();
for (var s in schema)
  v.addSchema(schema[s], schema[s].id);

// Adds ONE classroom to the database.
global.addClassroom = function addClassroom(newClassroom, callback) {
  if (type(newClassroom) == type.array) newClassroom = newClassroom[0]; // production

  if (type(callback) != type.function)
    callback = function(){};

  var valid = v.validate(newClassroom, '/classroom');
  if (valid.errors.length === 0)
    db.insert(newClassroom, callback);
  else if (type(callback) == type.function)
    callback(valid.errors);
};

global.deleteClassroom = function deleteClassroom(classroomId, callback) {
  if (type(callback) != type.function)
    callback = function(){};

  db.remove({'_id': classroomId}, callback);
};

// Perform some operations on a specified classroom.
global.withClassroom = function withClassroom(classroomId, callback) {
  if (type(callback) != type.function)
    callback = function(){};

  db.find({'_id': classroomId}, function(err, docs) {
    var classroom = docs[0];
    if (type(classroom) == type.object)
    {
      // Validate a classroom and save it to the database, calling callback if needed
      classroom.save = function(callback) {
        if (type(callback) != type.function)
          callback = function(){};

        // Must set these helper functions to undefined or they will get written
        classroom.save = undefined;
        classroom.addDevice = undefined;
        classroom.getDevice = undefined;
        classroom.deleteDevice = undefined;

        if (typeof classroom.devices === 'undefined')
          classroom.devices = [];

        classroom.devices.forEach(function(device) {
          device.sendObj = undefined;
        });

        var valid = v.validate(classroom, '/classroom');
        if (valid.errors.length === 0)
          db.update({'_id': classroomId}, {'$set': classroom}, callback);
        else
            callback(valid.errors);
      };

      // Add a device to the classroom, automatically assigning it an autoincrement id
      classroom.addDevice = function(newDevice) {
        assert(type(newDevice) == type.object, 'inappropriate device');

        if (type(classroom.deviceIndex) == type.undefined)
          classroom.deviceIndex = 0;
        if (typeof classroom.devices === 'undefined')
            classroom.devices = [];    

        newDevice._id = classroom.deviceIndex++;
        classroom.devices.push(newDevice);

        return newDevice;
      };

      // Get a device from the classroom, applying patch if needed.
      classroom.getDevice = function(id, patch) {
        // Find relevant device from an array of devices based on _id property.
        var index = classroom.devices.map(function(device) {
            return device._id;
          }).indexOf(parseInt(id));

        var device = classroom.devices[index];

        // Apply patch, without overwriting _id
        if (arguments.length == 2)
          for (var prop in patch)
            if (prop !== '_id')
              device[prop] = patch[prop];

        // Send a message to a device, if it is connected.
        device.sendObj = function(channel, message) {
          wsClient.conns.forEach(function(client) {
            if (type(client) != type.undefined && client.classroom === classroom._id && client._id == device._id)
              client.sendObj(channel, message);
          });
        };

        return device;
      };

      classroom.deleteDevice = function(id) {
        // Find relevant device from an array of devices based on _id property.
        var index = classroom.devices.map(function(device) {
            return device._id;
          }).indexOf(parseInt(id));

        classroom.devices.splice(index, 1);
      };
    }

    callback(err, classroom);
  });
};

ws = require('./wsHandler');
wsClient = ws.start(ports.wsClient);

app.on('ready', function() {
  mainWindow = new BrowserWindow({width: 800, height: 600});
  mainWindow.loadUrl('file://' + __dirname + '/admin/shell.html?' + ports.http);

  mainWindow.on('closed', function() {
    mainWindow = null;
  });
});

app.on('window-all-closed', function() {

  app.quit();
});
