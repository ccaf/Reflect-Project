(function(){
  var WebSocket = require('ws');

  var WebSocketServer;
  var conns = []; // an array of all active connections.
  var assoc = {}; // associates a connection uuid with a particular classroom and maybe device.

  // when a device looks at its own state, it consists of the app root object, which is shared amongst
  // all devices in a classroom that are running a particular app, and a 'self' property
  // where it can store its own state. It can not peek at other devices state, whether they are
  // on the same app or not. This function generates a device state based on the app that it is running,
  // or returns the classroom as state if appropriate.
  function generateState(classroom, _id) {
    if (typeof _id === 'undefined')
      return classroom;

    var state = {};
    var device = classroom.getDevice(_id);
    if (typeof classroom.appRoot === 'undefined') {
      classroom.appRoot = {};
      classroom.save();
    }

    assert(typeof device !== 'undefined', 'no device with that _id');

    for (var prop in classroom.appRoot[device.appId])
      if (prop !== 'deviceState')
        state[prop] = classroom.appRoot[device.appId][prop];

    if (typeof classroom.appRoot.deviceState[device.appId][device._id] === 'undefined')
      classroom.appRoot.deviceState[device.appId][device._id] = {};
    state.self = classroom.appRoot.deviceState[device.appId][device._id];

    return state;
  }

  var messageHandler = {
    // pairs a ws connection (which has a uuid) with a particular classroom and device.
    'data-associate': function(conn, message) {
      assoc[conn.uuid] = {'classroom': message.classroom, '_id': message._id};
      withClassroom(message.classroom, function(err, classroom) {
        conn.sendObj('data-update-state', {'state': generateState(classroom, message._id)});
        // notify all admins
        if (typeof message._id !== 'undefined')
          conns.forEach(function(otherConn) {
            if (assoc[otherConn.uuid].classroom === message.classroom && typeof assoc[otherConn.uuid]._id === 'undefined')
              otherConn.sendObj('data-update-state', classroom);
          });
      });
    },
    // a ws connection can either be paired to a classroom or a device and classroom. If the connection
    // is paired to a classroom only (i.e. it is an admin), it operates with that entire classroom as
    // its state. Otherwise, it has a state defined by the app it is running (see generateState()).
    'data-attempt-state': function(conn, message) {
      var lastAttempt;
      var state;
      withClassroom(assoc[conn.uuid].classroom, function(err, classroom) {
        // create appropriate state based on connection.
        if (typeof assoc[conn.uuid]._id === 'undefined')
          state = classroom;
        else
          state = generateState(classroom, assoc[conn.uuid]._id);

        message.attempts.some(function(attempt) {
          if (recursiveOneWayDiff(attempt.diff, state)) {
            lastAttempt = attempt.id;
            assign(attempt.patch, state);
            return false;
          }
          else
            return true;
        });

        classroom.save();

        // if any of the attempts were successful, need to notify all subscribers.
        if (typeof lastAttempt !== 'undefined')
          conns.forEach(function(otherConn) {
            if (assoc[otherConn.uuid].classroom === assoc[conn.uuid].classroom) {
              // don't notify self.
              if (otherConn == conn)
                return;
              // if state changer is admin, notify all devices.
              else if (typeof assoc[conn.uuid]._id === 'undefined')
                otherConn.sendObj('data-update-state', {'state': state});
              // if connection is an admin, notify it.
              else if (typeof assoc[otherConn.uuid]._id === 'undefined')
                otherConn.sendObj('data-update-state', {'state': state});
              // if two connections are sharing the same state, notify it.
              else if (assoc[otherConn.uuid]._id === assoc[conn.uuid]._id)
                otherConn.sendObj('data-update-state', {'state': state});
              // notify all other connections running the same app (with special app state).
              else if (classroom.getDevice(assoc[otherConn.uuid]._id).appId === classroom.getDevice(assoc[conn.uuid]._id).appId)
                otherConn.sendObj('data-update-state', {'state': generateState(classroom, assoc[otherConn.uuid]._id)});
            }
          });
        // and of course, notify the state changer.
        conn.sendObj('data-attempts-returned', {'uuid': conn.uuid, 'lastAttempt': lastAttempt, 'state': state});
      });
    }
  };

  module.exports.start = function(port) {
    WebSocketServer = new WebSocket.Server({'port': port});

    WebSocketServer.on('connection', function(conn) {
      // http://stackoverflow.com/a/2117523
      conn.uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });

      conn.sendObj = function(channel, message) {
        conn.send(JSON.stringify({'channel': channel, 'message': message}));
      };

      conns.push(conn);

      conn.on('message', function(json) {
        var envelope = JSON.parse(json);
        if (envelope.channel in messageHandler)
          messageHandler[envelope.channel](conn, envelope.message);
      });

      conn.on('close', function() {
        conns.splice(conns.map(function(conn) { return conn.uuid; }).indexOf(conn.uuid), 1);
        delete assoc[conn.uuid];
      });

      conn.sendObj('event-successful-connection', {'uuid': conn.uuid});

    });

    return WebSocketServer;
  };

  function unStringReplace(val) {
    if (val === '$$null$$')
      return null;

    if (val === '$$undefined$$')
      return undefined;

    return val;
  }

  function stringReplace(val) {
    if (val === null)
      return '$$null$$';

    if (typeof val === 'undefined')
      return '$$undefined$$';

    return val;
  }

  // returns true if object passes
  function recursiveOneWayDiff(left, right) {
    if (left instanceof Array)
    {
      if (!(right instanceof Array))
        return false;

      for (var i = 0; i < left.length; i++)
      {
        if (left[i] === null)
          continue;
        else if (typeof left[i] === 'undefined' && typeof right[i] === 'undefined')
          continue;
        else if (typeof left[i] !== 'undefined' && typeof right[i] === 'undefined')
          return false;
        else if (!isPOJS(left[i])) {
          if (!propDiff(left[i], right[i])) {
            return false;
          }
        }
        else if (!isPOJS(right[i]))
          return false;
        else if (!recursiveOneWayDiff(left[i], right[i]))
          return false;
      }
    }
    else
    {
      if (typeof right !== 'object')
        return false;

      for (var prop in left)
      {
        if (typeof left[prop] === 'undefined' && typeof right[prop] === 'undefined')
          continue;
        else if (!(prop in right))
          return false;
        else if (!isPOJS(left[prop])) {
          if (!propDiff(left[prop], right[prop])) {
            return false;
          }
        }
        else if (!isPOJS(right[prop]))
          return false;
        else if (!recursiveOneWayDiff(left[prop], right[prop]))
          return false;
      }
    }

    return true;
  }

  function isPOJS(prop) {
    return !(
      prop instanceof Date ||
      prop instanceof RegExp ||
      prop instanceof String ||
      prop instanceof Number) &&
      typeof prop === 'object';
  }

  // returns true if non-obj props are equal
  function propDiff(left, right) {
    if (isNaN(left) && isNaN(right) && typeof left === 'number' && typeof right === 'number')
      return true;
    else if (left === right)
      return true;
    else if (left.toString() === right.toString())
        return true;

    return false;
  }

  function itr(left, right, indexOrProp) {
    if (left[indexOrProp] instanceof Array) {
      if (right[indexOrProp] instanceof Array)
        assign(left[indexOrProp], right[indexOrProp]);
      else
        assign(left[indexOrProp], right[indexOrProp] = []);
    }
    else if (isPOJS(left[indexOrProp])) {
      if (isPOJS(right[indexOrProp]))
        assign(left[indexOrProp], right[indexOrProp]);
      else
        assign(left[indexOrProp], right[indexOrProp] = {});
    }
    else if (left[indexOrProp] !== null && typeof left[indexOrProp] !== 'undefined')
      right[indexOrProp] = unStringReplace(left[indexOrProp]);
  }

  // recursively assigns left to right
  function assign(left, right) {
    if (left instanceof Array)
      left.forEach(function(item, index) {
        itr(left, right, index);
      });
    else {
      for (var prop in left) {
        itr(left, right, prop);
      }
    }
    return right;
  }

}());
