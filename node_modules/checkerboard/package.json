{
  "name": "checkerboard",
  "version": "0.1.6",
  "description": "Shared transactional memory with zero server-side logic.",
  "author": {
    "name": "Gregory Fabry",
    "email": "glfabry2@illinois.edu"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gregoryfabry/checkerboard.git"
  },
  "main": "main.js",
  "scripts": {
    "test": "istanbul cover ./node_modules/mocha/bin/_mocha -- ./test/"
  },
  "dependencies": {
    "ws": "^0.7.2"
  },
  "devDependencies": {
    "chai": "^3.0.0",
    "istanbul": "^0.3.15",
    "mocha": "^2.2.5"
  },
  "license": "MIT",
  "readme": "![cards example](/examples/demo.gif?raw=true)\r\n\r\nCheckerboard is a library that lets you easily create shared state among clients with zero server-side logic. It has two components: a server back-end written with node.js, and a client library for the browser. Its goal is simplicity: the cards demo is less than a hundred lines of JavaScript.\r\n\r\n## Theory\r\n\r\nSuppose you have some state that you want to share among multiple networked clients. Each client can perform some change on the state at any time. How can we ensure that the clients' states stay consistent and in sync?\r\n\r\nFor example:\r\n\r\nLet's say the state has a counter, an integer that can be incremented by one. If client A increments the counter, and then client B also increments the counter before it receives the data from client A, client B's change will be lost.\r\n\r\nInstead of blindly making a change, a client submits an attempt. Each attempt has a 'diff', which is a record of what data the client has, and a 'patch', which is the change the client wants to make. When the server receives an attempt, it compares the diff to its own state. If the client has accurate data, then it applies the patch. Otherwise, it notifies that client with the updated state and lets it try again.\r\n\r\nThe 'diff' doesn't contain the entire state. Rather, it contains only the parts of the state that the client depended on to make a change. Even if a value is not written, a change might depend on a value that is read. (For example, if a value A is less than 10, add 1 to value B - we don't write value A but we want to make sure we have the right data).\r\n\r\n## Install\r\n\r\n    npm install checkerboard --save\r\n\r\n## Example\r\n\r\nTo run the example:\r\n\r\n    $ cd examples\r\n    $ node server.js\r\n\r\nIn examples/cards.html change the WebSocket address to whatever address you are hosting on. (localhost works fine if you are just on your own machine). Then, open cards.html in your browser. Try opening it in two tabs and seeing how changes are synced, and persist when you refresh.\r\n\r\n## Use\r\n\r\n### Server\r\n\r\n    var port = 904;\r\n    var Checkerboard = require('checkerboard');\r\n    var CheckerboardServer = new Checkerboard.Server(port, [optionalState]);\r\n\r\nThe server constructor takes one or two arguments: a port, and optionally a starting state. If you do not provide a starting state, it will just create an empty object and use that.\r\n\r\nThe constructor returns an event emitter with 'open' and 'close' events. Also,\r\n\r\n    CheckerboardServer.on('open', function(conn) {\r\n      // ... assign state, etc\r\n    });\r\n\r\nSometimes you want to give different states to different devices. To do this, assign a state function to the 'conn' parameter of the event callback. This function takes the base state and returns the state that you want to give to the client. For example:\r\n\r\n    CheckerboardServer.on('open', function(conn) {\r\n      conn.state = function(state) {\r\n        if (admin[conn.uuid] === true)\r\n          return state;\r\n        else\r\n          return state[conn.uuid];\r\n      };\r\n    });\r\n\r\nCheckerboard also emits when it receives a message from the client. (More on this in next section). You can send a message to a client with conn.sendObj(channel, message).\r\n\r\n    var state = CheckerboardServer.state; // save to file, etc\r\n\r\n### Browser\r\n\r\nInclude:\r\n\r\n    <script src=\"lib/checkerboard.js\"></script>\r\n    <script src=\"lib/q.min.js\"></script>\r\n\r\nThen:\r\n\r\n    var ws = new WebSocket('ws://localhost:904');\r\n    ws.onopen = function() {\r\n      var cb = new Checkerboard(ws);\r\n    }\r\n\r\n\r\nOn the client side, Checkerboard exposes two events and four methods.\r\n\r\n    cb.on('ready', function(state) { /* ... */ }); // called when initial state received\r\n\r\n    cb.on('change', function(state) { /* ... */ }); // called when state changed (NOT on initial receive!)\r\n\r\nNote that you cannot change state in an onready or onchange function. Whenever you want to change the state, you must call try(callback) like this:\r\n\r\n    cb.try(function(state) {\r\n      state('property', 'newValue');\r\n    });\r\n\r\nThe try method, as its name implies, tries to make a state change. If it fails, then it tries again until it succeeds.\r\n\r\nThe callback function receives one parameter, which is a \"diffable state.\" It uses getters and setters to change its values. Here is how getters and setters are used:\r\n\r\n*Note: getters and setters have changed in 0.1.*\r\n\r\nRead a property:\r\n\r\n    state('property');\r\n\r\nWrite a property:\r\n\r\n    state('property', 'value');\r\n\r\nNested properties:\r\n\r\n    state.nested.moreNested('property');\r\n\r\nArrays:\r\n\r\n    state.array[0]('property')\r\n\r\n**CAVEAT: some property names are 'forbidden': anything that is a Function property or in Function.prototype.** The full list is:\r\n\r\n    arguments, arity, caller, displayName, length, name, prototype, apply, bind, call, isGenerator, toSource, toString\r\n\r\nIf you want to access properties with these names, you must do the following:\r\n\r\n    state.person('name') // quoted access is okay\r\n    state.person._name('first') // otherwise prepend with an underscore\r\n\r\nOnce you make some changes, you want to call the sync() method:\r\n\r\n    cb.try(function(state) {\r\n      state.property('newValue');\r\n    });\r\n\r\n    cb.sync();\r\n\r\nCalling sync() with no parameters does a single sync. Calling sync(timeout) with a value in milliseconds sets an interval which repeatedly syncs state. Of course, if there are no state changes then nothing is submitted to the server. Changes from the server ('upstream') are always pushed. Calling sync(null) clears the timeout.\r\n\r\nCheckerboard exposes a 'send' method:\r\n\r\n    cb.send(channel, message);\r\n\r\nThe server emits an event when it receives a message:\r\n\r\n    CheckerboardServer.on(channel, function(conn, message) {\r\n      // you can write props straight to conn for later retrieval  \r\n    })\r\n\r\nCheckerboard also has a uuid() function, which returns an id unique to that connection. This is useful if you want to 'claim' something (for example in cards.html when a card is picked up, the client sets the card's hold property to its uuid, so no other client can pick it up.)\r\n\r\nLastly, try() returns a promise, so you can call a function when the state change is successful:\r\n\r\n    cb.try(function(state) {\r\n      /* ... */\r\n    }).then(function(newState) {\r\n      // render some html with correct state, etc.\r\n    }).done();\r\n\r\nCheckerboard uses Q for promises. Two caveats: changes made in a then callback WON'T be saved - the new state is read only. Any state change always occurs in a try block. I recommend calling done() or using some of Q's error handling features, otherwise any errors in your callbacks will be silenced.\r\n\r\n## Current issues\r\n\r\nv0.0.1:\r\n- Overwriting an entire array or object will fail to erase previous properties.\r\n",
  "readmeFilename": "README.md",
  "gitHead": "46224434a301f64dc4732d196c14980e70e6644f",
  "bugs": {
    "url": "https://github.com/gregoryfabry/checkerboard/issues"
  },
  "homepage": "https://github.com/gregoryfabry/checkerboard#readme",
  "_id": "checkerboard@0.1.6",
  "_shasum": "6e83fb3ea65a301e86b89b576b50f7401a63d8b2",
  "_from": "checkerboard@>=0.1.0 <0.2.0"
}
