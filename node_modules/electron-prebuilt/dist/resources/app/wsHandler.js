(function(){
  var WebSocket = require('ws');

  var WebSocketServer;
  var conns = []; // an array of all active connections.
  var assoc = {}; // associates a connection uuid with a particular classroom and maybe device.

  // when a device looks at its own state, it consists of the app root object, which is shared amongst
  // all devices in a classroom that are running a particular app, and a 'self' property
  // where it can store its own state. It can not peek at other devices state, whether they are
  // on the same app or not. This function generates a device state based on the app that it is running,
  // or returns the classroom as state if appropriate.
  function generateState(classroom, _id) {
    assert(typeof classroom !== 'undefined', 'no such classroom');

    if (typeof classroom.appRoot === 'undefined') {
      classroom.appRoot = {};
    }

    if (typeof _id === 'undefined')
      return classroom;

    var state = {};
    var device = classroom.getDevice(_id);

    assert(typeof device !== 'undefined', 'no device with that _id');

    for (var prop in classroom.appRoot[device.appId])
      if (prop !== 'deviceState')
        state[prop] = classroom.appRoot[device.appId][prop];

    if (typeof device.appId !== 'undefined') {
      if (typeof classroom.appRoot[device.appId] === 'undefined')
        classroom.appRoot[device.appId] = {'deviceState': {}};
      if (typeof classroom.appRoot[device.appId].deviceState[device._id] === 'undefined')
        classroom.appRoot[device.appId].deviceState[device._id] = {};

      state.self = classroom.appRoot[device.appId].deviceState[device._id];
      state.appId = device.appId;
    }
    console.log(classroom);
    return state;
  }

  function notifyAdminStateChange(classroom) {
    conns.forEach(function(otherConn) {
      if (otherConn.uuid in assoc && assoc[otherConn.uuid].classroom === classroom._id && typeof assoc[otherConn.uuid]._id === 'undefined')
        otherConn.sendObj('data-update-state', {'state': classroom});
    });
  }

  var messageHandler = {
    // pairs a ws connection (which has a uuid) with a particular classroom and device.
    'data-associate': function(conn, message) {
      assoc[conn.uuid] = {'classroom': message.classroom, '_id': message._id};
      withClassroom(message.classroom, function(err, classroom) {
        if (typeof message._id !== 'undefined') {
          classroom.getDevice(message._id).connected = true;
          notifyAdminStateChange(classroom);
        }
        conn.sendObj('data-update-state', {'uuid': conn.uuid, 'state': generateState(classroom, message._id)});
        classroom.save();
      });
    },
    // a ws connection can either be paired to a classroom or a device and classroom. If the connection
    // is paired to a classroom only (i.e. it is an admin), it operates with that entire classroom as
    // its state. Otherwise, it has a state defined by the app it is running (see generateState()).
    'data-attempt-state': function(conn, message) {
      var lastAttempt;
      var state;

      if (typeof assoc[conn.uuid] === 'undefined' || typeof assoc[conn.uuid].classroom === 'undefined')
        return;

      withClassroom(assoc[conn.uuid].classroom, function(err, classroom) {
        // create appropriate state based on connection.
        if (typeof assoc[conn.uuid]._id === 'undefined')
          state = classroom;
        else
          state = generateState(classroom, assoc[conn.uuid]._id);

        message.attempts.some(function(attempt) {
          if (recursiveOneWayDiff(attempt.diff, state)) {
            lastAttempt = attempt.id;
            assign(attempt.patch, state);
            console.log(state);
            return false;
          }
          else
            return true;
        });

        // if any of the attempts were successful, need to notify all subscribers.
        if (typeof lastAttempt !== 'undefined')
          conns.forEach(function(otherConn) {
            if (otherConn.uuid in assoc && typeof assoc[otherConn.uuid] !== 'undefined' && assoc[otherConn.uuid].classroom === assoc[conn.uuid].classroom) {
              // don't notify self.
              if (otherConn == conn)
                return;
              // if state changer is admin, notify all devices.
              else if (typeof assoc[conn.uuid]._id === 'undefined')
                otherConn.sendObj('data-update-state', {'state': generateState(classroom, assoc[otherConn.uuid]._id)});
              // if connection is an admin, notify it.
              else if (typeof assoc[otherConn.uuid]._id === 'undefined')
              otherConn.sendObj('data-update-state', {'state': generateState(classroom, assoc[otherConn.uuid]._id)});
              // if two connections are sharing the same state, notify it.
              else if (assoc[otherConn.uuid]._id === assoc[conn.uuid]._id)
              otherConn.sendObj('data-update-state', {'state': generateState(classroom, assoc[otherConn.uuid]._id)});
              // notify all other connections running the same app (with special app state).
              else if (classroom.getDevice(assoc[otherConn.uuid]._id).appId === classroom.getDevice(assoc[conn.uuid]._id).appId)
                otherConn.sendObj('data-update-state', {'state': generateState(classroom, assoc[otherConn.uuid]._id)});
            }
          });
        // and of course, notify the state changer.
        conn.sendObj('data-attempts-returned', {'uuid': conn.uuid, 'lastAttempt': lastAttempt, 'state': state});
        classroom.save();
      });
    }
  };

  module.exports.start = function(port) {
    WebSocketServer = new WebSocket.Server({'port': port});
    WebSocketServer.conns = conns;

    WebSocketServer.on('connection', function(conn) {
      // http://stackoverflow.com/a/2117523
      conn.uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });

      conn.sendObj = function(channel, message) {
        conn.send(JSON.stringify({'channel': channel, 'message': message}));
      };

      conns.push(conn);

      conn.on('message', function(json) {
        var envelope = JSON.parse(json);
        if (envelope.channel in messageHandler)
          messageHandler[envelope.channel](conn, envelope.message);
      });

      conn.on('close', function() {
        conns.splice(conns.map(function(conn) { return conn.uuid; }).indexOf(conn.uuid), 1);
        var savedAssoc = assoc[conn.uuid];
        if (typeof savedAssoc !== 'undefined' && typeof savedAssoc._id !== 'undefined')
          withClassroom(savedAssoc.classroom, function(err, classroom) {
            classroom.getDevice(savedAssoc._id).connected = false;
            classroom.save();
            notifyAdminStateChange(classroom);
          });
        delete assoc[conn.uuid];
      });
    });

    return WebSocketServer;
  };

  function unStringReplace(val) {
    if (val === '__null__')
      return null;

    if (val === '__undefined__')
      return undefined;

    return val;
  }

  function stringReplace(val) {
    if (val === null)
      return '__null__';

    if (typeof val === 'undefined')
      return '__undefined__';

    return val;
  }

  // returns true if object passes
  function recursiveOneWayDiff(left, right) {
    if (left instanceof Array)
    {
      if (!(right instanceof Array))
        return false;

      for (var i = 0; i < left.length; i++)
      {
        if (left[i] === null)
          continue;
        else if (typeof left[i] === 'undefined' && typeof right[i] === 'undefined')
          continue;
        else if (typeof left[i] !== 'undefined' && typeof right[i] === 'undefined')
          return false;
        else if (!isPOJS(left[i])) {
          if (!propDiff(left[i], right[i])) {
            return false;
          }
        }
        else if (!isPOJS(right[i]))
          return false;
        else if (!recursiveOneWayDiff(left[i], right[i]))
          return false;
      }
    }
    else
    {
      if (typeof right !== 'object')
        return false;

      for (var prop in left)
      {
        if (typeof left[prop] === 'undefined' && typeof right[prop] === 'undefined')
          continue;
        else if (!(prop in right))
          return false;
        else if (!isPOJS(left[prop])) {
          if (!propDiff(left[prop], right[prop])) {
            return false;
          }
        }
        else if (!isPOJS(right[prop]))
          return false;
        else if (!recursiveOneWayDiff(left[prop], right[prop]))
          return false;
      }
    }

    return true;
  }

  function isPOJS(prop) {
    return !(
      prop instanceof Date ||
      prop instanceof RegExp ||
      prop instanceof String ||
      prop instanceof Number) &&
      typeof prop === 'object';
  }

  // returns true if non-obj props are equal
  function propDiff(left, right) {
    if (isNaN(left) && isNaN(right) && typeof left === 'number' && typeof right === 'number')
      return true;
    else if (left === right)
      return true;
    else if (left.toString() === right.toString())
        return true;

    return false;
  }

  function itr(left, right, indexOrProp) {
    if (left[indexOrProp] instanceof Array) {
      if (right[indexOrProp] instanceof Array)
        assign(left[indexOrProp], right[indexOrProp]);
      else
        assign(left[indexOrProp], right[indexOrProp] = []);
    }
    else if (isPOJS(left[indexOrProp])) {
      if (isPOJS(right[indexOrProp]))
        assign(left[indexOrProp], right[indexOrProp]);
      else
        assign(left[indexOrProp], right[indexOrProp] = {});
    }
    else if (left[indexOrProp] !== null && typeof left[indexOrProp] !== 'undefined') {
      right[indexOrProp] = unStringReplace(left[indexOrProp]);
      if (typeof right[indexOrProp] === 'undefined') {
        if (right instanceof Array)
          right.splice(indexOrProp, 1);
        else
          delete right[indexOrProp];
      }
    }
  }

  // recursively assigns left to right
  function assign(left, right) {
    if (left instanceof Array)
      left.forEach(function(item, index) {
        itr(left, right, index);
      });
    else {
      for (var prop in left) {
        itr(left, right, prop);
      }
    }
    return right;
  }

}());
